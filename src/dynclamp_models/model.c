#ifdef __LOCAL_SIMULATION_ENV__

#include "model.h"

#endif

//############# START DYNAMIC_CLAMP CODE ##################

/*!
Dynamic clamp model for a current generated by multiple clusters of cooperative ion channels:
I_{coop} = -g*N_{open}*(V-E)
where the number of open channels N_{open} changes due to the stochastic opening and closing events guided by rates
which depend on the external voltage and the number of open channels among the surrounding channels in a cluster i.e.
alpha(V, o) and beta(V,o)

\par Input/Output
- V: Measured membrane potential in mV
- \f$ I_{inj} \f$ : Injected current in nA

\par Parameter
- g : conductance of a single channel in nS
- E : reversal potential of the ionic current in  mV
- cN: number of clusters of cooperative ion channels without units
- cS: number of cooperative ion channels in a cluster without units
- J : pairwise interaction strength in mV
- tau : peak reaction time scale of a single channel in ms
*/

#ifndef __KERNEL__

#include <gsl/gsl_rng.h>
#include <time.h>

#endif


#define POWER_2_EXP 28
unsigned long next = 1;
const int RAND_PERIOD = 1 << POWER_2_EXP;

// numerical recipes in c, p. 276, not recommended for usage as the period is 30k and other issues
float evil_rand(void) {
    next = next * 1103515245 + 1234;
    return (float) ((unsigned int) (next / 65536) % 32768) / 32768;
}

#if defined (__KERNEL__) || defined (DYNCLAMPMODEL)

/*! Name, by which this module is known inside Linux: */
const char *modelName;

/*! Variables used by the model */
#define MAX_CLUSTER_SIZE 8
#define DEFAULT_CLUSTER_NUMBER 100
#define DEFAULT_CLUSTER_INIT 0
int cluster_states[MAX_CLUSTER_SIZE + 1] = {DEFAULT_CLUSTER_NUMBER, 0, 0, 0, 0, 0, 0, 0, 0};
int cluster_size = MAX_CLUSTER_SIZE;
int cluster_number = DEFAULT_CLUSTER_NUMBER;
int cluster_init = DEFAULT_CLUSTER_INIT;

/*! The period length of the realtime periodic task in seconds. */
float loopInterval;
/*! One over the period length of the realtime periodic task in Hertz. */
float loopRate;

/*! Analog input that is read from the DAQ board. */

#define INPUT_N 1
/*! The \a inputNames are used to match the \a input variables with
analog input traces in Relacs. */
const char *inputNames[INPUT_N] = {"V-1"};
const char *inputUnits[INPUT_N] = {"mV"};
/*! The \a inputChannels are set automatically. */
int inputChannels[INPUT_N];
/*! \a input holds the current value that was read in from the DAQ board. */
float input[INPUT_N] = {0.0};

/*! Analog output that is written to the DAQ board. */

#define OUTPUT_N 1
const char *outputNames[OUTPUT_N] = {"Current-1"};
const char *outputUnits[OUTPUT_N] = {"nA"};
int outputChannels[OUTPUT_N];
float output[OUTPUT_N] = {0.0};

/*! Parameter that are provided by the model and can be read out. */

#define PARAMINPUT_N 2
const char *paramInputNames[PARAMINPUT_N] = {"Cooperative-Cluster-Current", "Open-Channels"};
const char *paramInputUnits[PARAMINPUT_N] = {"nA", ""};
float paramInput[PARAMINPUT_N] = {0.0, 0.0};

/*! Parameter that are read by the model and are written to the model. */

#define PARAMOUTPUT_N 8
const char *paramOutputNames[PARAMOUTPUT_N] = {"g", "E", "J", "tau", "Cluster size", "Number of clusters", "Vhalf", "Initial state"};
const char *paramOutputUnits[PARAMOUTPUT_N] = {"pS", "mV", "mV", "ms", "", "", "mV", ""};
float paramOutput[PARAMOUTPUT_N] = {0.0, 0.0, 0.0, 15, MAX_CLUSTER_SIZE, DEFAULT_CLUSTER_NUMBER, -1.0, 0};


/*! Functions used by the model */
double opening_rate(double voltage) {
    double oR;
    float vhalf = paramOutput[6];
    if (paramOutput[3] != 0.0) {
        oR = cosh((voltage - vhalf) / 30.0) * (1.0 + tanh((voltage - vhalf) / 15.0)) / paramOutput[3] / 2.0;
    } else {
        oR = 0;
    }
    return oR;
}

double closing_rate(double voltage) {
    double cR;
    float vhalf = paramOutput[6];
    if (paramOutput[3] != 0.0) {
        cR = cosh((voltage - vhalf) / 30.0) * (1.0 - tanh((voltage - vhalf) / 15.0)) / paramOutput[3] / 2.0;
    } else {
        cR = 0;
    }
    return cR;
}


double get_rand(void) {
    double u;

#ifdef ENABLE_LOOKUPTABLES
    // random number from lookuptable:
    next = (next >= (RAND_PERIOD - 1)) ? 0 : (next + 1);
    u = (double) lookupx[0][next];
#else
    u = (double) evil_rand();
#endif
    return u;
}


int get_number_of_open_channels(void) {
    int sum = 0;
    int size = cluster_size;
    int i;
    for (i = 0; i <= size; i++) {
        sum += cluster_states[i] * i;
    }
    return sum;
}


/*
brute_force on cluster state basis: rates based, does not need any internal state
- needs 2*cluster_size random numbers per time step
- problem: as multiple reactions might take place in a single time step an opening and a closing reaction might take
place simultaneously leaving behind an inconsistent state e.g. [0 1 0] -> [1 -1 1]
*/
void evolve_cluster_states(void) {
    double rand;
    double dt = loopInterval * 1000;
    double voltage = input[0];
    int cS = cluster_size;
    float cluster_interaction = paramOutput[2];

    //helpers
    int i;
    double opening_rates[cS];
    double closing_rates[cS];

    // calculate opening and closing rates
    for (i = 0; i < cS; i++) {
        // opening_rate[i]: rate from (i channels open) to (i+1 channels open)
        opening_rates[i] = cluster_states[i] * (cS - i) * opening_rate(voltage + i * cluster_interaction);
        // closing_rate[i]: rate from (i+1 channels open) to (i channels open)
        closing_rates[i] = cluster_states[i + 1] * (i + 1) * closing_rate(voltage + i * cluster_interaction);
    }

    // update cluster states
    for (i = 0; i < cS; i++) {
        //opening reaction from (i channels open) to (i+1 channels open)
        rand = get_rand();
        if (rand <= opening_rates[i] * dt) {
            //DEBUG_MSG("C -> Likelihood %.16f, Threshold:%.16f\n", opening_rates[i]*dt, rand);
            //DEBUG_MSG("Opening %d:%d\n", i, cluster_states[i]);
            if (cluster_states[i] != 0) {
                cluster_states[i] -= 1;
                cluster_states[i + 1] += 1;
            }
        }

        // closing reaction from (i+1 channels open) to (i channels open)
        rand = get_rand();
        if (rand <= closing_rates[i] * dt) {
            //DEBUG_MSG("C -> Likelihood %.16f, Threshold:%.16f\n", closing_rates[i]*dt, rand);
            //DEBUG_MSG("Closing %d:%d\n", i+1,cluster_states[i+1]);
            if (cluster_states[i + 1] != 0) {
                cluster_states[i + 1] -= 1;
                cluster_states[i] += 1;
            }
        }
    }
}


void populate_state(int state_idx) {
    int idx;
    cluster_states[state_idx] = cluster_number;
    for (idx = 0; idx <= cluster_size; idx++) {
            if(idx != state_idx) {
                cluster_states[idx] = 0;
            }
        }
}


void process_cluster_property_changes(void) {
    int cluster_size_idx = 4;
    int cluster_number_idx = 5;
    int cluster_init_idx = 7;

    if (cluster_size != (int) paramOutput[cluster_size_idx] ||
        cluster_number != (int) paramOutput[cluster_number_idx] || cluster_init != (int) paramOutput[cluster_init_idx]) {
        if (paramOutput[cluster_size_idx] > MAX_CLUSTER_SIZE) {
            cluster_size = MAX_CLUSTER_SIZE;
        } else {
            cluster_size = (paramOutput[cluster_size_idx] >= 1) ? (int) paramOutput[cluster_size_idx] : 1;
        };

        if (paramOutput[cluster_init_idx] > MAX_CLUSTER_SIZE) {
            cluster_init = MAX_CLUSTER_SIZE;
        } else {
            cluster_init = (paramOutput[cluster_init_idx] >= 0) ? (int) paramOutput[cluster_init_idx] : 0;
        };


        cluster_number = (paramOutput[cluster_number_idx] > 0) ? (int) paramOutput[cluster_number_idx] : 0;

        populate_state(cluster_init);
    }
}


/*! Functions provided by the model for the dynamic clamp module */


void initModel(void) {
    modelName = "cooperative_clusters";
    process_cluster_property_changes();
}

#define CONDUCTANCE_IDX 0
#define MEMBRANE_POTENTIAL_IDX 0
#define REVERSAL_POTENTIAL_IDX 1

void computeModel(void) {

    int number_of_open_channels = 0;
    process_cluster_property_changes();
    evolve_cluster_states();
    // number of open channels
    number_of_open_channels = get_number_of_open_channels();
    paramInput[0] = (float) (-0.000001 * paramOutput[CONDUCTANCE_IDX] * number_of_open_channels *
            (input[MEMBRANE_POTENTIAL_IDX] - paramOutput[REVERSAL_POTENTIAL_IDX]));
    // current flowing through cooperative clusters :
    paramInput[1] = number_of_open_channels;
    // total injected current:
    output[0] = paramInput[0];
}

#endif

#ifndef __KERNEL__
#ifdef ENABLE_LOOKUPTABLES

/*! This function is called from DynClampAnalogOutput in user
    space/C++ context and can be used to create some lookuptables for
    nonlinear functions to be used by computeModel(). The implementation of this
    functions has to allocate an \a x and \a y array of floats of a sensible size \a n.
    \param[in] \a k : the index for the lookup table to be generated.
    \param[out] \a n : the size of the lookup table (the number of elements in \a x and \a y).
    \param[out] \a x : the x-values.
    \param[out] \a y : the corresponding y-values.
    \return: 0 if a lookuptable was generated, -1 otherwise.
*/

gsl_rng *rng_state;

unsigned long get_seed_from_clock();

void initialize_random_number_generator() {
    const gsl_rng_type *T;
    unsigned long int seed = get_seed_from_clock();

    gsl_rng_env_setup();
    T = gsl_rng_default;

    rng_state = gsl_rng_alloc(T);
    gsl_rng_set(rng_state, seed);
}

unsigned long get_seed_from_clock() {
    clock_t current;
    current = clock();
    return (unsigned long int) current;
}


int generateLookupTable(int k, float **x, float **y, int *n) {
    initialize_random_number_generator();
    if (k == 0) {
        /* Lookup-table for the Random number generator: */
        const int nn = RAND_PERIOD;
        *n = nn;
#ifdef __LOCAL_SIMULATION_ENV__
        *x = (float *) malloc(nn * sizeof(float));
#else
        *x = new float[nn];
#endif
        for (int j = 0; j < nn; j++) {
            float xx = gsl_rng_uniform(rng_state);
            (*x)[j] = xx;
        }
        return 0;
    }

    return -1;
}

#endif
#endif

//############# END DYNAMIC_CLAMP CODE ##################

#ifdef __LOCAL_SIMULATION_ENV__

void setVoltage(float voltage) {
    input[0] = voltage;
}

void setConductance(float conductance) {
    paramOutput[0] = conductance;
}

void setReversalPotential(float reversalPotential) {
    paramOutput[1] = reversalPotential;
}

void setClusterInteraction(float clusterInteraction) {
    paramOutput[2] = clusterInteraction;
}

void setTimeConstant(float timeConstant) {
    paramOutput[3] = timeConstant;
}

void setClusterSize(float clusterSize) {
    paramOutput[4] = clusterSize;
}

void setClusterNumber(float clusterNumber) {
    paramOutput[5] = clusterNumber;
}

void setVhalf(float vhalf) {
    paramOutput[6] = vhalf;
}

void setClusterInit(float clusterInit) {
    paramOutput[7] = clusterInit;
}

void setLoopInterval(float interval) {
    loopInterval = interval;
}

float getCurrentOutput(void) {
    return output[0];
}

int getClusterSize(void) {
    return cluster_size;
}

int getClusterState(int i) {
    return cluster_states[i];
}

#endif
